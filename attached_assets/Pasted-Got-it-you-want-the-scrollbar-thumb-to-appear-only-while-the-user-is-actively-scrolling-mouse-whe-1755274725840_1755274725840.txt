Got it — you want the scrollbar thumb to appear only while the user is actively scrolling (mouse wheel, arrow keys, touch/drag), then fade away. Here’s a small, robust pattern that works across desktop + mobile (Chrome, Edge, Firefox, Safari).

1) HTML

Add a class to any scrollable container you want to auto-hide:

<div class="scrollbox" id="myList">
  <!-- tall content -->
</div>

2) CSS

Hidden by default.

Becomes visible only while the element has .scrolling (which we toggle via JS).

Firefox uses scrollbar-width; WebKit browsers get ::-webkit-scrollbar styling.

/* Base: make it scrollable */
.scrollbox {
  overflow: auto;
  /* optional: smoother appearance */
  -webkit-overflow-scrolling: touch;
}

/* --- Firefox --- */
.scrollbox {                 /* hidden by default */
  scrollbar-width: none;     /* hides both track and thumb */
}
.scrollbox.scrolling {       /* show a thin bar while scrolling */
  scrollbar-width: thin;
  scrollbar-color: color-mix(in oklab, CanvasText 50%, transparent) transparent;
}

/* --- WebKit (Chrome, Edge, Safari) --- */
.scrollbox::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

/* Hide by default (keep gutter minimal/transparent) */
.scrollbox::-webkit-scrollbar-thumb,
.scrollbox::-webkit-scrollbar-track {
  background: transparent;
}

/* Show only while .scrolling is present */
.scrollbox.scrolling::-webkit-scrollbar-thumb {
  background: rgba(0,0,0,0.35);      /* visible thumb */
  border-radius: 8px;
}
.scrollbox.scrolling::-webkit-scrollbar-track {
  background: rgba(0,0,0,0.06);      /* subtle track (optional) */
}

/* Nice fade-in/out */
.scrollbox,
.scrollbox::-webkit-scrollbar-thumb,
.scrollbox::-webkit-scrollbar-track {
  transition: background 180ms ease, color 180ms ease;
}

3) JS (adds/removes .scrolling while user is interacting)
<script>
function attachAutoHideScrollbar(el, hideDelay = 400) {
  let t;
  const show = () => {
    el.classList.add('scrolling');
    clearTimeout(t);
    t = setTimeout(() => el.classList.remove('scrolling'), hideDelay);
  };

  // Any interaction that implies scrolling intent:
  const opts = { passive: true };
  el.addEventListener('scroll', show, opts);
  el.addEventListener('wheel', show, opts);
  el.addEventListener('touchstart', show, opts);
  el.addEventListener('touchmove', show, opts);
  el.addEventListener('pointerdown', show, opts);
  el.addEventListener('keydown', (e) => {
    // Show when using keyboard to scroll
    const keys = ['ArrowUp','ArrowDown','PageUp','PageDown','Home','End','Space'];
    if (keys.includes(e.key)) show();
  });

  // Clean up state when pointer leaves (optional)
  el.addEventListener('mouseleave', () => el.classList.remove('scrolling'));
}

// Attach to specific boxes
attachAutoHideScrollbar(document.getElementById('myList'));

// Or attach to all
// document.querySelectorAll('.scrollbox').forEach(attachAutoHideScrollbar);
</script>

Notes / tips

Works on mobile (touch/drag triggers touchmove + scroll).

macOS may already auto-hide system scrollbars; this still ensures visibility during active scroll and invisibility when idle.

If you want global page scroll behavior (for the whole body), apply the CSS to html, body and call attachAutoHideScrollbar(document.documentElement) — but container-level is usually safer.